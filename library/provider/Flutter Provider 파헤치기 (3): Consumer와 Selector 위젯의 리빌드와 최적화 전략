# Flutter Provider 파헤치기 (3): Consumer와 Selector 위젯의 리빌드와 최적화 전략

*2023년 12월 13일*

---

안녕하세요! Flutter Provider 시리즈 세 번째 시간입니다. 지난 글에서는 Provider의 기본 개념과 `ChangeNotifierProvider`를 이용한 데이터 변경 알림에 대해 알아보았습니다.

* [Flutter Provider 파헤치기 (1): Provider 기본 개념과 사용법](https://velog.io/@s_soo100/Flutter-Provider-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-1-Provider-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%82%AC%EC%9A%A9%EB%B2%95)
* [Flutter Provider 파헤치기 (2): ChangeNotifierProvider와 데이터 변경 알림](https://velog.io/@s_soo100/Flutter-Provider-%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-2-ChangeNotifierProvider%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B3%80%EA%B2%BD-%EC%95%8C%EB%A6%BC)

이번 글에서는 Provider 상태 변화를 감지하고 UI를 업데이트하는 데 핵심적인 역할을 하는 `Consumer`와 `Selector` 위젯에 대해 자세히 알아보고, 불필요한 리빌드를 줄여 앱 성능을 최적화하는 전략을 살펴보겠습니다.

## Consumer 위젯: 기본 사용법과 리빌드 범위

`Consumer` 위젯은 Provider가 노출하는 **객체의 변화를 구독**하고, 변화가 감지될 때마다 `builder` 함수를 호출하여 **UI를 다시 그리는** 가장 기본적인 위젯입니다.

![image](https://velog.velcdn.com/images/s_soo100/post/7bb54c24-a87a-4b34-a710-020a3064017f/image.png)

**기본 구조:**

```dart
Consumer<MyModel>( // 구독할 모델 타입 지정
  builder: (context, myModel, child) {
    // context: BuildContext
    // myModel: 구독 중인 모델 객체의 최신 인스턴스
    // child: 리빌드와 상관없이 유지될 수 있는 자식 위젯 (최적화에 사용)

    // myModel의 데이터를 사용하여 UI를 빌드
    return Text('Value: ${myModel.someValue}');
  },
  // child: ExpensiveWidget(), // 리빌드가 필요 없는 무거운 위젯은 여기에 배치
)
Consumer의 특징:

데이터 변화 감지: Provider로부터 제공받는 MyModel 객체에 변화가 생기면 (notifyListeners() 호출 등) builder 함수가 다시 호출됩니다.
전체 리빌드: 기본적으로 Consumer 위젯 하위의 builder 함수 내에서 반환되는 모든 위젯 트리가 리빌드됩니다. 모델의 특정 값 하나만 변경되어도, 해당 모델을 사용하는 전체 UI 조각이 다시 그려지는 것이죠.
간편함: 기본적인 상태 관리에 직관적이고 사용하기 편리합니다.
리빌드 범위의 문제점:

만약 MyModel이 여러 데이터를 가지고 있고, 그중 아주 작은 부분만 변경되었는데도 Consumer의 builder 전체가 다시 실행된다면 불필요한 리빌드가 발생하여 성능 저하의 원인이 될 수 있습니다. 특히 복잡한 UI나 목록 아이템 등에서 이러한 문제가 두드러질 수 있습니다.

Selector 위젯: 필요한 데이터만 구독하기
Selector 위젯은 Consumer와 유사하지만, Provider가 제공하는 객체 전체가 아닌 특정 데이터만 선택(select)하여 구독할 수 있게 해줍니다. 이를 통해 선택한 데이터가 변경될 때만 builder 함수를 호출하여 리빌드를 수행하므로, 불필요한 UI 업데이트를 최소화할 수 있습니다.

기본 구조:

Dart

Selector<MyModel, int>( // <모델 타입, 선택할 데이터 타입>
  selector: (context, myModel) => myModel.specificValue, // 모델에서 특정 값만 선택
  builder: (context, specificValue, child) {
    // context: BuildContext
    // specificValue: selector를 통해 선택된 값
    // child: 리빌드와 상관없는 자식 위젯

    // 선택된 specificValue만 사용하여 UI를 빌드
    // myModel의 다른 값이 변경되어도 이 빌더는 다시 호출되지 않음
    return Text('Specific Value: $specificValue');
  },
  // shouldRebuild: (previous, next) => previous != next, // 기본적으로 값이 변경될 때만 리빌드
  // child: ExpensiveWidget(),
)
Selector의 특징:

선택적 구독: selector 콜백을 통해 모델 객체에서 UI 렌더링에 필요한 특정 데이터만 추출합니다.
최적화된 리빌드: selector가 반환하는 값이 이전 값과 다를 경우에만 builder 함수가 호출됩니다. 모델의 다른 속성이 변경되어도 선택된 값이 같다면 리빌드되지 않습니다.
정밀한 제어: 복잡한 상태 객체에서 특정 부분의 변경에만 반응하도록 정밀하게 제어할 수 있어 성능 최적화에 유리합니다.
여러 값 선택하기:

만약 여러 값을 선택해야 한다면, selector에서 Tuple (tuple 패키지), List, Map 또는 별도의 작은 클래스/객체를 반환하도록 구현할 수 있습니다.

Dart

Selector<MyModel, Tuple2<String, int>>( // 예시: Tuple2 사용 (tuple 패키지 필요)
  selector: (context, myModel) => Tuple2(myModel.name, myModel.count),
  builder: (context, data, child) {
    // data.item1 (name), data.item2 (count) 사용
    return Column(
      children: [
        Text('Name: ${data.item1}'),
        Text('Count: ${data.item2}'),
      ],
    );
  },
  // shouldRebuild: (previous, next) => previous != next, // 기본 동작, 필요시 커스텀 가능
)
이때 shouldRebuild 콜백을 커스텀하여 리빌드 조건을 더 세밀하게 제어할 수도 있습니다. (기본적으로 previous != next 비교 수행)

Consumer vs Selector: 언제 무엇을 사용할까?
구분	Consumer	Selector
구독 대상	모델 객체 전체	selector를 통해 선택된 특정 데이터
리빌드 조건	모델 객체 변경 시 (notifyListeners())	selector 반환 값이 이전 값과 다를 때
주요 장점	간편함, 직관적인 사용	성능 최적화, 정밀한 리빌드 제어
주요 단점	불필요한 리빌드 발생 가능성	약간의 코드 복잡도 증가, selector 구현 필요
사용 시점	- 간단한 UI 업데이트&lt;br>- 모델 전체 데이터가 필요한 경우&lt;br>- 성능 영향이 미미한 경우	- 성능 최적화가 중요한 경우&lt;br>- 복잡한 모델에서 특정 데이터만 필요한 경우&lt;br>- 불필요한 리빌드를 최소화해야 하는 경우

Sheets로 내보내기
결론적으로:

Consumer: 프로토타이핑이나 간단한 위젯처럼 성능에 민감하지 않거나 모델 전체가 필요한 경우에 사용하면 편리합니다.
Selector: 리스트 아이템, 복잡한 대시보드 위젯 등 성능 최적화가 중요하고 불필요한 리빌드를 피해야 하는 대부분의 경우에 사용하는 것이 좋습니다.
최적화 팁: 불필요한 리빌드 줄이기
Consumer와 Selector를 효과적으로 사용하여 성능을 최적화하는 몇 가지 추가 팁입니다.

Selector 적극 활용: 가장 중요한 최적화 방법입니다. 가능한 경우 Consumer 대신 Selector를 사용하여 필요한 데이터만 구독하세요.

child 파라미터 활용: Consumer와 Selector의 builder 외부에서 생성된 위젯은 모델 데이터 변경과 상관없이 리빌드되지 않아야 합니다. 이러한 위젯은 Consumer/Selector의 child 파라미터로 전달하면, builder가 호출될 때마다 새로 생성되지 않고 재사용되어 성능에 도움이 됩니다.

Dart

Consumer<MyModel>(
  // ExpensiveWidget은 MyModel 데이터와 상관 없으므로 child로 전달
  child: ExpensiveWidget(),
  builder: (context, myModel, child) {
    return Column(
      children: [
        Text('Value: ${myModel.someValue}'),
        child!, // 여기서 재사용 (null safety 주의)
      ],
    );
  },
)
const 키워드 활용: 리빌드될 필요가 없는 정적인 위젯에는 const 키워드를 적극적으로 사용하세요. const 위젯은 컴파일 타임에 상수로 처리되어 런타임에 재생성되지 않습니다.

데이터 구조 설계: 상태 모델(ChangeNotifier를 상속한 클래스 등)을 설계할 때, 관련 있는 데이터끼리 묶고 UI 조각들이 필요한 최소한의 데이터만 구독할 수 있도록 구조를 잘 설계하는 것이 중요합니다. 너무 거대한 단일 모델은 상태 변경 시 불필요한 전파를 일으킬 수 있습니다.

리빌드 범위 확인: DevTools 활용
Flutter DevTools는 위젯 리빌드 범위를 시각적으로 확인하고 성능 병목 현상을 찾는 데 매우 유용한 도구입니다.

Flutter Inspector: 'Repaint Rainbow' 옵션을 켜면 리빌드되는 위젯들이 무지개색 테두리로 표시되어 어느 부분이 자주 업데이트되는지 쉽게 파악할 수 있습니다.
Performance View: 앱의 프레임 속도, CPU 사용량 등을 모니터링하고, 특정 프레임에서 어떤 작업이 오래 걸리는지 분석할 수 있습니다.
(DevTools의 Repaint Rainbow 예시)

Consumer나 Selector를 적용한 후 DevTools를 이용해 의도한 대로 리빌드 범위가 최적화되었는지 확인하는 습관을 들이는 것이 좋습니다.

결론
Consumer와 Selector는 Flutter Provider 패키지에서 상태 변화에 따라 UI를 업데이트하는 핵심 위젯입니다. Consumer는 사용하기 간편하지만 불필요한 리빌드를 유발할 수 있는 반면, Selector는 필요한 데이터만 선택적으로 구독하여 성능 최적화에 매우 효과적입니다.

앱의 성능을 고려한다면, 특히 복잡하거나 자주 업데이트되는 UI에서는 Selector를 우선적으로 사용하는 것이 좋습니다. 여기에 child 파라미터 활용, const 키워드 사용, 적절한 데이터 모델링, 그리고 DevTools를 통한 검증을 병행하면 더욱 효율적이고 반응성 좋은 Flutter 애플리케이션을 만들 수 있을 것입니다.

다음 글에서는 Provider의 또 다른 유용한 기능들에 대해 더 알아보겠습니다. 궁금한 점이나 잘못된 내용이 있다면 댓글로 알려주세요!
